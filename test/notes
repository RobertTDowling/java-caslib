[ ] factoring integer scalars vs polynomials can't promote to factored
    first because we lose the context.

[ ] but if we DON'T promote, we can't make a factored be the output

[ ] perhaps factory needs to save the incoming types

[ ] I need this also for power function

[ ] since we instantiate a factory already, maybe having it hold some
    state isn't so bad. The the values that came in

[ ] do I need Binop factories and unop factories?

[ ] array of stackables

------------------------------------------------------------------------------

Thu Apr 23 06:31:16 PDT 2015

[x] Got All the rpncalcn functions implemented, and hand-tested

[x] Need test51 to succeed on converting PrimeFactored + Scalar = Scalar
 -- it was a mistake in Sclalar making FactoredPolynomial instead of PrimeFact

[x] Need restriction now, because 2x/x = 2, a polynomial, instead of 2 a Scalar

Sat Apr 25 10:48:37 PDT 2015

[/] Restriction by trying to simplify in the computation causes a
    problem in ver9 (backed up working into ver9a).  In order to
    return a restrict after say Polynomial division 2x/x, we need
    Polynomial.div to return Stackable, not Polynomial.  I've hacked
    this up in ver9, but it required making a set of _add, _sub, etc,
    that do return Polynomial, so that they can be used in the
    implementation of Polynomial division, which is written in terms
    of add, sub, etc.

Sat Apr 25 12:46:35 PDT 2015

    Perhaps a better approach would be to perform restriction outside
    the Polynomial class.

    [ ] Restriction in StackApp was good enough, except that it
        restricted anything that could be expressed as a scalar to a
        scalar....  Thus primefactors reverted back to scalars.  I
        need to test for Polynomials or FactoredPolynomials holding
        scalars.  When it was done in the Polynoimal class, I knew it
        was legit.  What new test do I add to Stackable for that?

        Currently, isScalar() returns true if whatever type it is, it
        could be expressed as a scalar.  What do we want to happen?

	Scalar(3) --> unchanged
	PF(3^1*2^2) --> unchanged or Scalar(12)?
	Poly(2x) -> unchanged because it can't be changed
	Poly(2) -> Scalar(2)
	FP((2x-1)*(x+2)) -> unchanged because it can't be changed
	FP(3)*(4)) -> Scalar(12) or PF(3^1*2^2)?

	Need to resolve the two ? cases above

	[ ] How do we decide when a PF should become a scalar?

	    R for when to restrict, x for leave alone:

	        +0 *1
	    S    x  x
	    PF   R  x
	    P    R  x
	    FP   R  x

	[!] I suppose the most flexible is to put a call in each of
	    the classes Stackable restrict() that does restriction if
	    it makes sense.

	[no] another thought is to restrict on input to operation

	    P(2) * PF(2*3) == S(2) * S(6) = S(12)3^1*2^2)

	    But operations like

	    P(x+1) - P(x) = S(1)

	    won't happen.  You need to evaluate output to decide if it is
	    simpler than the inputs

	l is simpler   -S PF  P FP
	than r      -S  n  n  y  y
		    PF  n  n  ?  y
		    -P  n  n  n  n
		    FP  n  n  n  n

	When an operation on Vector types (P, FP) results in a Scalar
	type (S, PF), we want to restrict output to Scalar.

	Likewise, if we go from a vector in 2 vars to a vector in 1
	var, we also want to consider this a restriction.

	[!] Only allow restriction when human asks for it?

Sat Apr 25 16:21:34 PDT 2015

[ ] For now, create a restriction function I can run by hand

So I propose a string format....

   3.2x^2-yz+7 -> P(VS(x,y,z),[3:T(S(3.2),EV(0x100)),T(S(-1),EV(0x11)),T(S(7),EV(0))])
   5 -> S(5)
   (2)^3*(5) -> PF([2:(S(2),3),(S(5),1)])
   (x+1)(x-1) -> FP([2:P(VS(x),[2:T(S(1),EV(0x1)),T(S(1),EV(0))]),P(VS(x),[2:T(S(1),EV(0x1)),T(S(-1),EV(0))])])
   	      	    ^^^ Missing powers!  So incomplete

I propose another string format

   (2)^3*(5) -> PF((S(2),3),(S(5),1))
   3.2x^2-yz+7 -> P(VS(x,y,z),T(3.2,0x100),T(-1,0x11),T(7,0x0))
   (x+1)(x-1)^2 -> FP(PP(1,P(VS(x),T(1,0x1),T(1,0x0))),PP(2,P(VS(x),T(1,0x1),T(-1,0x0))))
  
I propose another string format
  T: <double,evec>   <3.2,0x10>
  M: [int,obj]       [2,P(...)]
  VS {v,v,...}	     {x,y,z}
  
  s f P F E

   5 -> S(5)
   (2)^3*(5) -> PF([3,S(2)],[1,S(5)])
   3.2x^2-yz+7 -> P({x,y,z},<3.2,0x100>,<-1,0x11>,<7,0x0>)
   (x+1)(x-1)^2 -> FP([1,P({x},<1,0x1>,<1,0x0>)],[2,P({x},<1,0x1>,<-1,0x0>)])
  

[ ] Test all ops on scalar

[ ] Calc15 building with SDK 21 instead of 19

[ ] RPNCalcN building with SDK 21 instead of 19

[ ] Power need to be calling reduce?

[ ] Calc + Render = Full Operation (what do we call this???)

[ ] Singleton ops?  Or OpFactory?

[ ] Rendering!  toString works
    Class RenderHelper
    Subclass HtmlHelper
    Subclass UTF8Helper

    [ ] Format for Error, NaN, PolynomialPower: handles x^0, x^1,
    +1*x, -1*x

    [ ] Flag for HTML output (rpncalcn) vs UTF-8 (which seems to be
    working in cas) --> Next

[ ] Test on my old phone - Galaxy Nexus

[ ] Rendering unified between HTML and UTF8

[ ] Factor on big value can be really slow!

[ ] / is not defined on factored types
    123 -> (41)(3) : 3 /  = (41)(3) still
    ditto polynomials???

[ ] Rendering is how rpncalcn handles things like primes and
factoring, because it can take time.  Now binop and unop can take
time.

   [ ] Perhaps the engine should be in its own thread, with a queue of
   computations and results

   [ ] Then binop would pop two values, and push a holder value,
   giving a handle to it to CalcEngine, which would fill it in when it
   was computed.  And rendered, I suppose.

   [ ] The whole model of rendering being how things are shown is
   backward compared to what cas does.  It makes object of different
   types, and each has its own toString()

   [ ] Handling slow things like "factor big polynomial" should push
       [ ] Stackable.Working() obj

Mon Apr 27 19:43:46 PDT 2015

So I propose a string format....

   3.2x^2-yz+7 -> P(VS(x,y,z),[3:T(S(3.2),EV(0x100)),T(S(-1),EV(0x11)),T(S(7),EV(0))])
   5 -> S(5)
   (2)^3*(5) -> PF([2:(S(2),3),(S(5),1)])
   (x+1)(x-1) -> FP([2:P(VS(x),[2:T(S(1),EV(0x1)),T(S(1),EV(0))]),P(VS(x),[2:T(S(1),EV(0x1)),T(S(-1),EV(0))])])
   	      	    ^^^ Missing powers!  So incomplete

I propose another string format

   (2)^3*(5) -> PF((S(2),3),(S(5),1))
   3.2x^2-yz+7 -> P(VS(x,y,z),T(3.2,0x100),T(-1,0x11),T(7,0x0))
   (x+1)(x-1)^2 -> FP(PP(1,P(VS(x),T(1,0x1),T(1,0x0))),PP(2,P(VS(x),T(1,0x1),T(-1,0x0))))
  
I propose another string format
  T: <double,evec>   <3.2,0x10>
  M: [int,obj]       [2,P(...)]
  VS {v,v,...}	     {x,y,z}
  
  s f P F E

   5 -> S(5)
   (2)^3*(5) -> PF([3,S(2)],[1,S(5)])
   3.2x^2-yz+7 -> P({x,y,z},<3.2,0x100>,<-1,0x11>,<7,0x0>)
   (x+1)(x-1)^2 -> FP([1,P({x},<1,0x1>,<1,0x0>)],[2,P({x},<1,0x1>,<-1,0x0>)])
  
More ideas on formats of serialize

  Scalar   s-12345435643
  Evec	   e3:1:0:1		first 3 is length of evec array
  Int	   i3			Used for powers
  VarSet   v2:x:y		Used for Polynomials
  Poly	   p2:x:y,s425234e3:1:0:1,s-4543541e3:0:0:0
  PrimeF   zi7z4523476;i1z3246124
  FPoly	   fi3p2:x:y,s425234e3:1:0:1,s-4543541e3:0:0:0;i1p1:y,s425234e2:1:1

;'s delimit chunks in factored objects
,'s delimit terms in poly
:'s delimit vars/evec values, but lengths are given first
factoreds, polys all use "append to current" strategy

Mon Apr 27 19:39:39 PDT 2015

Serialization

Output of test55.ic

0
Serialize=s0
1
Serialize=s4607182418800017408
-1
Serialize=s-4616189618054758400
(2)³(3)(31)
Serialize=zi3,s4611686018427387904*i1,s4613937818241073152*i1,s4629418941960159232
x
Serialize=pvx+s4607182418800017408,e1:1
x³-2x²y+xy²+3x²-6xy+3y²
Serialize=pvx:y+s4607182418800017408,e3:3:0+s-4611686018427387904,e3:2:1+s4607182418800017408,e3:1:2+s4613937818241073152,e2:2:0+s-4604930618986332160,e2:1:1+s4613937818241073152,e2:0:2
(x+3)(x-y)²
Serialize=fi1;pvx+s4607182418800017408,e1:1+s4613937818241073152,e0:0*i2;pvx:y+s4607182418800017408,e1:1:0+s-4616189618054758400,e1:0:1

[x] Can't make Scalar take 0xhex, because unsigned parser is broken

------------------------------------------------------------------------------

Sun May  3 13:43:48 PDT 2015

Factory a multivariable polynomial using rational root theorem

	http://en.wikipedia.org/wiki/Rational_root_theorem

If the polynomial to be factored is a_nx^n + ... + a_0, then all
possible linear factors are of the form b_1x-b_0, where b_1 is an
integer factor of a_n and b_0 is an integer factor of a_0.

(x+y+6)^3 = x³+3x²y+3xy²+y³+18x²+36xy+18y²+108x+108y+216

