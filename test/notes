[ ] factoring integer scalars vs polynomials can't promote to factored
    first because we lose the context.

[ ] but if we DON'T promote, we can't make a factored be the output

[ ] perhaps factory needs to save the incoming types

[ ] I need this also for power function

[ ] since we instantiate a factory already, maybe having it hold some
    state isn't so bad. The the values that came in

[ ] do I need Binop factories and unop factories?

[ ] array of stackables

------------------------------------------------------------------------------

Thu Apr 23 06:31:16 PDT 2015

[x] Got All the rpncalcn functions implemented, and hand-tested

[x] Need test51 to succeed on converting PrimeFactored + Scalar = Scalar
 -- it was a mistake in Sclalar making FactoredPolynomial instead of PrimeFact

[x] Need restriction now, because 2x/x = 2, a polynomial, instead of 2 a Scalar

Sat Apr 25 10:48:37 PDT 2015

[/] Restriction by trying to simplify in the computation causes a
    problem in ver9 (backed up working into ver9a).  In order to
    return a restrict after say Polynomial division 2x/x, we need
    Polynomial.div to return Stackable, not Polynomial.  I've hacked
    this up in ver9, but it required making a set of _add, _sub, etc,
    that do return Polynomial, so that they can be used in the
    implementation of Polynomial division, which is written in terms
    of add, sub, etc.

Sat Apr 25 12:46:35 PDT 2015

    Perhaps a better approach would be to perform restriction outside
    the Polynomial class.

    [ ] Restriction in StackApp was good enough, except that it
        restricted anything that could be expressed as a scalar to a
        scalar....  Thus primefactors reverted back to scalars.  I
        need to test for Polynomials or FactoredPolynomials holding
        scalars.  When it was done in the Polynoimal class, I knew it
        was legit.  What new test do I add to Stackable for that?

        Currently, isScalar() returns true if whatever type it is, it
        could be expressed as a scalar.  What do we want to happen?

	Scalar(3) --> unchanged
	PF(3^1*2^2) --> unchanged or Scalar(12)?
	Poly(2x) -> unchanged because it can't be changed
	Poly(2) -> Scalar(2)
	FP((2x-1)*(x+2)) -> unchanged because it can't be changed
	FP(3)*(4)) -> Scalar(12) or PF(3^1*2^2)?

	Need to resolve the two ? cases above

	[ ] How do we decide when a PF should become a scalar?

	    R for when to restrict, x for leave alone:

	        +0 *1
	    S    x  x
	    PF   R  x
	    P    R  x
	    FP   R  x

	[!] I suppose the most flexible is to put a call in each of
	    the classes Stackable restrict() that does restriction if
	    it makes sense.

	[no] another thought is to restrict on input to operation

	    P(2) * PF(2*3) == S(2) * S(6) = S(12)3^1*2^2)

	    But operations like

	    P(x+1) - P(x) = S(1)

	    won't happen.  You need to evaluate output to decide if it is
	    simpler than the inputs

	l is simpler   -S PF  P FP
	than r      -S  n  n  y  y
		    PF  n  n  ?  y
		    -P  n  n  n  n
		    FP  n  n  n  n

	When an operation on Vector types (P, FP) results in a Scalar
	type (S, PF), we want to restrict output to Scalar.

	Likewise, if we go from a vector in 2 vars to a vector in 1
	var, we also want to consider this a restriction.

	[!] Only allow restriction when human asks for it?

Sat Apr 25 16:21:34 PDT 2015

[ ] For now, create a restriction function I can run by hand

So I propose a string format....

   3.2x^2-yz+7 -> P(VS(x,y,z),[3:T(S(3.2),EV(0x100)),T(S(-1),EV(0x11)),T(S(7),EV(0))])
   5 -> S(5)
   (2)^3*(5) -> PF([2:(S(2),3),(S(5),1)])
   (x+1)(x-1) -> FP([2:P(VS(x),[2:T(S(1),EV(0x1)),T(S(1),EV(0))]),P(VS(x),[2:T(S(1),EV(0x1)),T(S(-1),EV(0))])])
   	      	    ^^^ Missing powers!  So incomplete

I propose another string format

   (2)^3*(5) -> PF((S(2),3),(S(5),1))
   3.2x^2-yz+7 -> P(VS(x,y,z),T(3.2,0x100),T(-1,0x11),T(7,0x0))
   (x+1)(x-1)^2 -> FP(PP(1,P(VS(x),T(1,0x1),T(1,0x0))),PP(2,P(VS(x),T(1,0x1),T(-1,0x0))))
  
I propose another string format
  T: <double,evec>   <3.2,0x10>
  M: [int,obj]       [2,P(...)]
  VS {v,v,...}	     {x,y,z}
  
  s f P F E

   5 -> S(5)
   (2)^3*(5) -> PF([3,S(2)],[1,S(5)])
   3.2x^2-yz+7 -> P({x,y,z},<3.2,0x100>,<-1,0x11>,<7,0x0>)
   (x+1)(x-1)^2 -> FP([1,P({x},<1,0x1>,<1,0x0>)],[2,P({x},<1,0x1>,<-1,0x0>)])
  

[ ] Test all ops on scalar

[ ] Calc15 building with SDK 21 instead of 19

[ ] RPNCalcN building with SDK 21 instead of 19

[ ] Power need to be calling reduce?

[ ] Calc + Render = Full Operation (what do we call this???)

[ ] Singleton ops?  Or OpFactory?

[ ] Rendering!  toString works
    Class RenderHelper
    Subclass HtmlHelper
    Subclass UTF8Helper

    [ ] Format for Error, NaN, PolynomialPower: handles x^0, x^1,
    +1*x, -1*x

    [ ] Flag for HTML output (rpncalcn) vs UTF-8 (which seems to be
    working in cas) --> Next

[ ] Test on my old phone - Galaxy Nexus

[ ] Rendering unified between HTML and UTF8

[ ] Factor on big value can be really slow!

[ ] / is not defined on factored types
    123 -> (41)(3) : 3 /  = (41)(3) still
    ditto polynomials???

[ ] Rendering is how rpncalcn handles things like primes and
factoring, because it can take time.  Now binop and unop can take
time.

   [ ] Perhaps the engine should be in its own thread, with a queue of
   computations and results

   [ ] Then binop would pop two values, and push a holder value,
   giving a handle to it to CalcEngine, which would fill it in when it
   was computed.  And rendered, I suppose.

   [ ] The whole model of rendering being how things are shown is
   backward compared to what cas does.  It makes object of different
   types, and each has its own toString()

   [ ] Handling slow things like "factor big polynomial" should push
       [ ] Stackable.Working() obj

Mon Apr 27 19:43:46 PDT 2015

So I propose a string format....

   3.2x^2-yz+7 -> P(VS(x,y,z),[3:T(S(3.2),EV(0x100)),T(S(-1),EV(0x11)),T(S(7),EV(0))])
   5 -> S(5)
   (2)^3*(5) -> PF([2:(S(2),3),(S(5),1)])
   (x+1)(x-1) -> FP([2:P(VS(x),[2:T(S(1),EV(0x1)),T(S(1),EV(0))]),P(VS(x),[2:T(S(1),EV(0x1)),T(S(-1),EV(0))])])
   	      	    ^^^ Missing powers!  So incomplete

I propose another string format

   (2)^3*(5) -> PF((S(2),3),(S(5),1))
   3.2x^2-yz+7 -> P(VS(x,y,z),T(3.2,0x100),T(-1,0x11),T(7,0x0))
   (x+1)(x-1)^2 -> FP(PP(1,P(VS(x),T(1,0x1),T(1,0x0))),PP(2,P(VS(x),T(1,0x1),T(-1,0x0))))
  
I propose another string format
  T: <double,evec>   <3.2,0x10>
  M: [int,obj]       [2,P(...)]
  VS {v,v,...}	     {x,y,z}
  
  s f P F E

   5 -> S(5)
   (2)^3*(5) -> PF([3,S(2)],[1,S(5)])
   3.2x^2-yz+7 -> P({x,y,z},<3.2,0x100>,<-1,0x11>,<7,0x0>)
   (x+1)(x-1)^2 -> FP([1,P({x},<1,0x1>,<1,0x0>)],[2,P({x},<1,0x1>,<-1,0x0>)])
  
More ideas on formats of serialize

  Scalar   s-12345435643
  Evec	   e3:1:0:1		first 3 is length of evec array
  Int	   i3			Used for powers
  VarSet   v2:x:y		Used for Polynomials
  Poly	   p2:x:y,s425234e3:1:0:1,s-4543541e3:0:0:0
  PrimeF   zi7z4523476;i1z3246124
  FPoly	   fi3p2:x:y,s425234e3:1:0:1,s-4543541e3:0:0:0;i1p1:y,s425234e2:1:1

;'s delimit chunks in factored objects
,'s delimit terms in poly
:'s delimit vars/evec values, but lengths are given first
factoreds, polys all use "append to current" strategy

Mon Apr 27 19:39:39 PDT 2015

Serialization

Output of test55.ic

0
Serialize=s0
1
Serialize=s4607182418800017408
-1
Serialize=s-4616189618054758400
(2)³(3)(31)
Serialize=zi3,s4611686018427387904*i1,s4613937818241073152*i1,s4629418941960159232
x
Serialize=pvx+s4607182418800017408,e1:1
x³-2x²y+xy²+3x²-6xy+3y²
Serialize=pvx:y+s4607182418800017408,e3:3:0+s-4611686018427387904,e3:2:1+s4607182418800017408,e3:1:2+s4613937818241073152,e2:2:0+s-4604930618986332160,e2:1:1+s4613937818241073152,e2:0:2
(x+3)(x-y)²
Serialize=fi1;pvx+s4607182418800017408,e1:1+s4613937818241073152,e0:0*i2;pvx:y+s4607182418800017408,e1:1:0+s-4616189618054758400,e1:0:1

[x] Can't make Scalar take 0xhex, because unsigned parser is broken

------------------------------------------------------------------------------

Sun May  3 13:43:48 PDT 2015

Factory a multivariable polynomial using rational root theorem

	http://en.wikipedia.org/wiki/Rational_root_theorem

If the polynomial to be factored is a_nx^n + ... + a_0, then all
possible linear factors are of the form b_1x-b_0, where b_1 is an
integer factor of a_n and b_0 is an integer factor of a_0.

(x+y+6)^3 = x³+3x²y+3xy²+y³+18x²+36xy+18y²+108x+108y+216

Factor in x: (1)x³+(3y+18)x²+(3y²+36y+108)x+(y³+18y²+108y+216)

Factor 1x³ = +/- 1, 1x, 1x², 1x³
Factor (y³+18y²+108y+216) = (y+6)³ = +/- 1, (y+6), (y+6)², (y+6)³

64 to test

------------------------------------------------------------------------------

Tue May  5 06:27:04 PDT 2015

How to make this easy?

f = Factor (p)
  if (p is not in one var)
     pick first var v
     make f in 1 var v, with polynomial coef
  else
     make f = p, but with each scalar coef replaced with degenerate polynomial 
  let lead = leading coef polynomial of f
  let last = last coef polynomial of f
  let flead = list of divisor polynomials of lead (not just factors)
  let flast = list of divisor polynomials of last
  for (a: flead) {
    for (b: flast) {
       let d = ax+b
       let q,r = f /mod d
       if r.isZero
         add d to l
	 if degree (q) < 2
	   add q to l
	   return
	 recurse -- this is the ugly part -- we need a polynomial with Scalar coef again!  Is it?
   failed... add q to l

l = list of divisors polynomials (p)

------------------------------------------------------------------------------

Wed May  6 06:53:59 PDT 2015

What are the divisors of...  4x^3+8x^2+4x ?  18 of them

     1, 2, 4,                       x, 2x, 4x,
     x+1, 2x+2, 4x+4,               x^2+x, 2x^2+2, 4x^2+4,
     (x+1)^2, 2(x+1)^2, 4(x+1)^2,   x(x+1)^2, 2x(x+1)^2, 4x(x+1)^2

{1,2,4} x {1,x} x {1,x+1,(x+1)^2} == 2^{0,1,2} x x^{0,1} x (x+1)^{0,1,2}

What is _the factorizaion_ of 4x^3+8x^2+4x ?

     (4x)(x+1)^2

So Factorization returns a FactoredPolynomial type

     Sum { PolyCoef x Variable ^ Power }

Whereas divisors need to return 3 lists of (object, power) pairs

     PrimeFactored scalar GCD
     Evec of variable GCD
     FactoredPolynomial of P/GCD

All three could be expressed a Factored objects

Or it could be one massive Factored object: 

     2^2, x^1, (x+1)^2

Hmmm.  We could remove the gcd x^1 by looking at the power of the last
term in the polynomial.  That leaves the 2^2 and x+1^2.  One is
scalar, one is polynomial with coef 1.

------------------------------------------------------------------------------

Polynomial [] lastFactored = factorInZ ();
FactoredPolynomial jj = new FactoredPolynomial (lastFactored);
			
// Lexicographic order on jj
Set<Stackable> tss = jj.sortKeys();
int lfcount = tss.size();
int [] exp = new int [lfcount];
int [] trial = new int [lfcount];
Polynomial [] base = new Polynomial [lfcount];
int i=0;
for (Stackable s: tss) {
	base[i] = (Polynomial) s;
	trial[i] = 0;
	exp[i++] = jj.get(s);
}

ArrayList<Polynomial> divisors = new ArrayList<Polynomial>();
i = 0;
while (i < lfcount) {
	Polynomial p = new Polynomial (new Scalar(1));
	for (i=0; i<lfcount; i++) {
		for (int j=0; j<trial[i]; j++) {
			p = p.mul (base[i]);
		}
	}

	// +/-P is a possible factor
	divisors.add (p);

	// Compute next trial
	for (i=0; i<lfcount; i++) {
		if (++trial[i] <= exp[i]) {
			break;
		}
		trial[i] = 0;
	}
}
return divisors;

------------------------------------------------------------------------------

Thu May  7 06:25:01 PDT 2015

Why is this so hard???

I'm getting wound up in trying to reuse code that can't be reused and
bad variable names and the fact that Emacs is not helping me with
refactoring and that I can't commit any of my work so it is a
minefield of commented out code I can't delete yet.

Look at more data

Could I end up with 4x^2 + 12xy + 9y^2 -- yes and ver11 factors that 2x+3y

But 4x^2 + 12xy^2 + 9y^4 can't be factored by ver11 because it does
not do powers of the variable y

Let's look at my algorithm again, and see if I can simplify it

Poly: S*E+...+S*E, and E=v^a*...*z^e
PolyOfPolyInOneVar: POPIOV
PolyInOneVarOfPoly: Pn*v^n+...+Pk*v^k, k might==0  PIOVOP

Construct all S*v+T, where S|Pn and T|Pk

They can be constructed on the fly, or all at once.  That is an optimization.

FactoredPolynomial factorInZ () // Let p be an alias to 'this'
  Pick v, the first variable in p.
  Create empty list<poly> l to hold factoriztion of p (Which then
       becomes a FactoredPolynomial?  It could if we "mul" by factors,
       but let's skip that for now.)
  factorInZ (v, l)
  Construct array from arraylist <-- is this step necessary
  Construct FactoredPolynoimal from array
------------------------------------------------------------------------------
Polynomial [] factorInZ () // Let p be an alias to 'this'
  Make p1 be a PIOVOP(v) that is eqivalent to p (what is the container?)
  lead, last, are Polynomial
  let lead = leading coef polynomial of p1 <-- This is array index basically
  let last = last coef polynomial of p1
  let ldlead = list of divisor Polynomials of lead (not just factors)
  let ldlast = list of divisor Polynomials of last <-- These are Polynomial
  for (s: ldlead) {
     for (t: ldlast) {
        let d = sv+b        <-- d is Polynomial
        let q,r = p /mod d  <-- q,r are Polynomial
        if r.isZero
           add d to l
	   if degree (q) < 2
	     also add q to l
	   return
	recurse: q.factorInZ (v, l)
  Leftovers... add q to l
------------------------------------------------------------------------------
list of divisor Polynomials of p
  Lexicographic order

Thu May  7 20:15:32 PDT 2015

Massive changes to Polynomial.j to try to factor more cases, like
test35-37, but still not there.  Yet this is working again and using
new direction.

Add GCD to Evec and Term.
Polynomial.expressIn returns array now.
Remove dead comments from boilerplat.pl.
Add constructor from Polynomial for PrimeFactored.
Add constructor from ArrayList<Polynomial> for FactoredPolynomial.

Sat May  9 08:21:02 PDT 2015

Commit it working for more cases in test35.ic except easiest x^2+2xy+y^2.

This is broken because we now express the last coef y^2 as
  1*y^2 + 0 y^1 + 0 y^0.

This appears to be solvable with GCD pulling y^2 and leaving 1 behind
